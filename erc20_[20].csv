run,time_taken,iterations,verified,annotated_contract,status
1,49.016499519348145,1,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
2,92.39023902930958,4,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * 
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice  postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice  postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice  postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice  postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice  postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice  postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice  postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
3,154.0488088130951,5,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    /// @notice postcondition _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - (msg.sender != to ? value : 0) || !success
    /// @notice postcondition _balances[to] == __verifier_old_uint(_balances[to]) + (msg.sender != to ? value : 0) || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    /// @notice postcondition _allowed[msg.sender][spender] == value || !success
    /// @notice postcondition (value == 0) || (_allowed[msg.sender][spender] == value)
    /// @notice postcondition _allowed[msg.sender][spender] == __verifier_old_uint(_allowed[msg.sender][spender]) || success
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
","[""Iteraction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[msg.sender] >= value || !success' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] == __verifier_old_uint(_balances[to]) + (success ? value : 0)' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 3\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - (success ? value : 0)' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 5\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - (success ? value : 0)' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
4,26.409940719604492,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
5,312.0768117904663,9,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender != to ) || ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender == to ) &&  success ) || !success
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender == to ) ) || !success
    /// @notice postcondition _balances[msg.sender] >= 0
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  && from != to ) || ( _balances[from] ==  __verifier_old_uint (_balances[from] ) && from == to ) && success ) || !success 
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && from != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && from == to ) && success ) || !success 
    /// @notice postcondition ( _allowed[from][msg.sender] ==  __verifier_old_uint (_allowed[from][msg.sender] ) - value && success) || ( _allowed[from][msg.sender] ==  __verifier_old_uint (_allowed[from][msg.sender]) && !success) || from == msg.sender
    /// @notice postcondition _allowed[from][msg.sender] <= __verifier_old_uint (_allowed[from][msg.sender] ) || from == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender][spender] == value && success) || (_allowed[msg.sender][spender] == __verifier_old_uint (_allowed[msg.sender][spender]) && !success)
    /// @notice postcondition _allowed[msg.sender][spender] == value || !success
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
","[""Iteraction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] >= 0' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:90:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 3\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] == __verifier_old_uint(_balances[to]) + value || !success' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:92:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:92:5: Postcondition '_allowed[msg.sender][spender] == __verifier_old_uint(_allowed[msg.sender][spender]) || !success' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 4\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] >= 0' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:91:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 5\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - value || !success' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:92:5: Postcondition '_allowed[msg.sender][spender] == __verifier_old_uint(_allowed[msg.sender][spender]) || !success' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 6\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] >= 0' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:91:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 7\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - value || !success' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:91:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 8\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] >= 0' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:91:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 9\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[to] >= 0' might not hold at end of function.\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:91:5: Postcondition '_allowed[msg.sender][spender] >= 0' might not hold at end of function.\nERC20::transferFrom: OK\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
6,26.94401979446411,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * 
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice  postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice  postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice  postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice  postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice  postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice  postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice  postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
7,66.74083757400513,2,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - value && msg.sender != to ) || ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == to )
    /// @notice postcondition ( _balances[to] == __verifier_old_uint(_balances[to]) + value && msg.sender != to ) || ( _balances[to] == __verifier_old_uint(_balances[to]) && msg.sender == to )
    /// @notice postcondition _balances[to] >= __verifier_old_uint(_balances[to])
    /// @notice postcondition _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - value || msg.sender == to
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[from] == __verifier_old_uint(_balances[from]) - value && from != to ) || ( _balances[from] == __verifier_old_uint(_balances[from]) && from == to )
    /// @notice postcondition ( _balances[to] == __verifier_old_uint(_balances[to]) + value && from != to ) || ( _balances[to] == __verifier_old_uint(_balances[to]) && from == to )
    /// @notice postcondition _allowed[from][msg.sender] == __verifier_old_uint(_allowed[from][msg.sender]) - value || from == msg.sender
    /// @notice postcondition _allowed[from][msg.sender] <= __verifier_old_uint(_allowed[from][msg.sender]) || from == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition _allowed[msg.sender][spender] == value
    /// @notice postcondition success == true
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
","[""Iteraction: 1\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition 'success == (_balances[msg.sender] >= value)' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:108:5: Postcondition 'success == (_balances[from] >= value && _allowed[from][msg.sender] >= value)' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Iteraction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '_balances[msg.sender] >= value' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:108:5: Postcondition '_allowed[from][msg.sender] >= value' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
8,46.50580430030823,1,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - value && msg.sender != to) || (msg.sender == to)
    /// @notice postcondition (_balances[to] == __verifier_old_uint(_balances[to]) + value && msg.sender != to) || (msg.sender == to)
    /// @notice postcondition success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (_balances[from] == __verifier_old_uint(_balances[from]) - value && from != to) || (from == to)
    /// @notice postcondition (_balances[to] == __verifier_old_uint(_balances[to]) + value && from != to) || (from == to)
    /// @notice postcondition (_allowed[from][msg.sender] == __verifier_old_uint(_allowed[from][msg.sender]) - value && from != msg.sender) || (from == msg.sender)
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender][spender] == value && success) || (_allowed[msg.sender][spender] == __verifier_old_uint(_allowed[msg.sender][spender]) && !success)
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
9,26.39528179168701,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);
    
    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice  postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice  postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice  postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice  postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice  postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice  postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice  postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
10,26.77212882041931,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - value  && msg.sender  != to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == to ) &&  success )   || !success
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  && msg.sender  != to ) ||   ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) && msg.sender  == to )  )   || !success
    function transfer(address to, uint value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( ( _balances[from] ==  __verifier_old_uint (_balances[from] ) - value  &&  from  != to ) || ( _balances[from] ==  __verifier_old_uint ( _balances[from] ) &&  from == to ) && success ) || !success 
    /// @notice postcondition ( ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) + value  &&  from  != to ) || ( _balances[to] ==  __verifier_old_uint ( _balances[to] ) &&  from  == to ) && success ) || !success 
    /// @notice postcondition ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender] ) - value && success) || ( _allowed[from ][msg.sender] ==  __verifier_old_uint (_allowed[from ][msg.sender]) && !success) ||  from  == msg.sender
    /// @notice postcondition  _allowed[from ][msg.sender]  <= __verifier_old_uint (_allowed[from ][msg.sender] ) ||  from  == msg.sender
    function transferFrom(address from, address to, uint value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender ][ spender] ==  value  &&  success) || ( _allowed[msg.sender ][ spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ spender] ) && !success )    
    function approve(address spender, uint value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[owner] == balance
    function balanceOf(address owner) public view returns (uint balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[owner][spender] == remaining
    function allowance(address owner, address spender) public view returns (uint remaining);
}
",[]
