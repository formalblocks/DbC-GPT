run,time_taken,iterations,verified,annotated_contract,function_status,status
1,679.2259104251862,42,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition approved == __verifier_old_bool(approved) || _owner == address(0)
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition true
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'safeTransferFrom': 'Failed', 'safeBatchTransferFrom': 'Failed'}",[]
2,414.35345339775085,24,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition approved == __verifier_old_bool(approved) || _owner != address(0)
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition _to != address(0)
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition _to != address(0)
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'safeTransferFrom': 'Verified', 'safeBatchTransferFrom': 'Verified'}",[]
3,749.5404331684113,51,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition true
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'safeTransferFrom': 'Failed', 'safeBatchTransferFrom': 'Failed'}",[]
4,730.1202275753021,51,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    /// @notice postcondition forall (uint x) !(0 <= x && x < _id) || balance == __verifier_old_uint(balance)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition true
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'safeTransferFrom': 'Failed', 'safeBatchTransferFrom': 'Failed'}",[]
5,755.770546913147,52,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == __verifier_old_uint(balance)
    /// @notice postcondition forall (uint x) !(0 <= x && x < _id) || balance == __verifier_old_uint(balance)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition true
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'safeTransferFrom': 'Failed', 'safeBatchTransferFrom': 'Failed'}",[]
6,710.4574782848358,52,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == __verifier_old_uint(balance)
    /// @notice postcondition forall (uint x) !(0 <= x && x < _id) || balance == __verifier_old_uint(balance)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition true
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'safeTransferFrom': 'Failed', 'safeBatchTransferFrom': 'Failed'}",[]
7,326.1514747142792,24,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition true
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition approved == __verifier_old_bool(approved) || _owner != address(0)
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition _to != address(0)
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition _to != address(0)
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Failed', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'safeTransferFrom': 'Verified', 'safeBatchTransferFrom': 'Verified'}",[]
8,369.24583768844604,24,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition approved == __verifier_old_bool(approved) || _owner == address(0)
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition _to != address(0)
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition _to != address(0)
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'safeTransferFrom': 'Verified', 'safeBatchTransferFrom': 'Verified'}",[]
9,698.4281923770905,51,False,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition true
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition true
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'safeTransferFrom': 'Failed', 'safeBatchTransferFrom': 'Failed'}",[]
10,177.7520775794983,7,True,"pragma solidity >= 0.5.0;

contract ERC1155 {

    // Events
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // State Variables
    string private _uri;

    // Functions
    /// @notice postcondition balance == __verifier_old_uint(balance) || _owner != address(0)
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition batchBalances.length == _owners.length
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _operator != address(0)
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition approved == __verifier_old_bool(approved) || _operator != address(0)
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition _to != address(0)
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition _ids.length == _values.length
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;

}
","{'balanceOf': 'Verified', 'balanceOfBatch': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'safeTransferFrom': 'Verified', 'safeBatchTransferFrom': 'Verified'}",[]
