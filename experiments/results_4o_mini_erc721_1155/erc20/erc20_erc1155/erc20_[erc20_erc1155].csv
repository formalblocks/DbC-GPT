run,time_taken,iterations,verified,annotated_contract,status
1,35.22481632232666,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to && success) 
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to && success) 
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to && success)
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to && success)
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition _allowed[msg.sender][_spender] == _value && success || (_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success)
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
2,33.716702699661255,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * @notice postcondition supply == _totalSupply
    */
    function totalSupply() public view returns (uint256 supply);

    /**
    * @notice  postcondition ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - _value && msg.sender != _to ) || ( _balances[msg.sender] == __verifier_old_uint ( _balances[msg.sender] ) && msg.sender == _to && success )
    * @notice  postcondition ( _balances[_to] ==  __verifier_old_uint ( _balances[_to] ) + _value && msg.sender != _to ) || ( _balances[_to] == __verifier_old_uint ( _balances[_to] ) && msg.sender == _to && success )
    */
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * @notice  postcondition ( _balances[_from] ==  __verifier_old_uint (_balances[_from] ) - _value && _from != _to ) || ( _balances[_from] == __verifier_old_uint ( _balances[_from] ) && _from == _to && success )
    * @notice  postcondition ( _balances[_to] ==  __verifier_old_uint ( _balances[_to] ) + _value && _from != _to ) || ( _balances[_to] == __verifier_old_uint ( _balances[_to] ) && _from == _to && success )
    * @notice  postcondition _allowed[_from][msg.sender] == __verifier_old_uint (_allowed[_from][msg.sender]) - _value || ( _allowed[_from][msg.sender] == __verifier_old_uint (_allowed[_from][msg.sender]) && !success )
    * @notice  postcondition _allowed[_from][msg.sender] <= __verifier_old_uint (_allowed[_from][msg.sender]) || _from == msg.sender
    */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * @notice  postcondition _allowed[msg.sender][_spender] == _value || (_allowed[msg.sender][_spender] == __verifier_old_uint (_allowed[msg.sender][_spender]) && !success)
    */
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * @notice postcondition _balances[_owner] == balance
    */
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * @notice postcondition _allowed[_owner][_spender] == remaining
    */
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
3,438.13184213638306,10,False,,"[""Interaction: 1\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 3\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 4\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 5\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 6\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 7\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 8\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 9\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 10\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:105:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
4,34.19938850402832,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to) && success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to) && success
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value && success
    /// @notice postcondition _allowed[_from][msg.sender] <= __verifier_old_uint(_allowed[_from][msg.sender]) || _from == msg.sender
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender][_spender] == _value && success) || (_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success)
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
5,42.68892192840576,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to) && success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to) && success
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value && success
    /// @notice postcondition _allowed[_from][msg.sender] <= __verifier_old_uint(_allowed[_from][msg.sender]) || _from == msg.sender
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender][_spender] == _value && success) || (_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success)
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
6,45.719998836517334,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to && success) 
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to && success) 
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to && success)
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to && success)
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value || (_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success)
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition _allowed[msg.sender][_spender] == _value || (_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success)
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
7,37.85564613342285,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to) && success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to) && success
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value && success
    /// @notice postcondition _allowed[_from][msg.sender] <= __verifier_old_uint(_allowed[_from][msg.sender]) || _from == msg.sender
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /// @notice postcondition (_allowed[msg.sender][_spender] == _value && success) || (_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success)
    function approve(address _spender, uint256 _value) public returns (bool success);

    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
8,36.611607789993286,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to) && success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to) && success
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to) && success
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value && success
    /// @notice postcondition _allowed[_from][msg.sender] <= __verifier_old_uint(_allowed[_from][msg.sender]) || _from == msg.sender
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (_allowed[msg.sender][_spender] == _value && success) || (_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success)
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
9,27.613831520080566,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /// @notice postcondition ( _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && msg.sender != _to ) || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && msg.sender == _to && success)
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && msg.sender != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && msg.sender == _to && success)
    function transfer(address _to, uint256 _value) public returns (bool success);

    /// @notice postcondition ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _from != _to ) || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _from == _to && success)
    /// @notice postcondition ( _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _from != _to ) || (_balances[_to] == __verifier_old_uint(_balances[_to]) && _from == _to && success)
    /// @notice postcondition _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value || (_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success)
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /// @notice postcondition _allowed[msg.sender][_spender] == _value && success || _allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success
    function approve(address _spender, uint256 _value) public returns (bool success);

    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
10,443.45149326324463,10,False,,"[""Interaction: 1\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 3\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 4\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 5\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 6\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 7\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 8\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 9\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 10\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:88:5: Postcondition '_allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]) && !success' might not hold at end of function.\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:106:5: Postcondition '_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) && !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
