Thread ID: thread_XjC4vDJexqF830rFKUbG4tN1
Request Type: erc123
Context: none_verifyIdentityByTrustedVerifier
Run: 1

=== USER [2025-05-14 03:43:40] ===

        
        
    Task: - You are given a smart contract interface and need to add formal postconditions to a function using solc-verify syntax (/// @notice postcondition condition). Postconditions must not end with a semicolon (";"). - You MUST use the EIP documentation below to understand the required behavior. - Replace $ADD POSTCONDITION HERE with appropriate postconditions above each function. Postconditions placed below the function signature are invalid. For instance: /// @notice postcondition condition1
 /// @notice postcondition condition2
 function foo(uint256 bar, address par) public;

    Requirements: - Ensure conditions correctly represent the expected state changes and return values. - View functions should relate return values directly to state variables. - Postconditions MUST ONLY use state variables exactly as declared. Referencing undeclared variables will fail if they aren't in the contract. For instance, a state variable uint256 var can be referenced as var only. - Postconditions MUST ONLY use parameter names exactly as they appear in function signatures. For instance, function foo(uint256 bar, address par) has parameter names bar and par only. - Use __verifier_old_uint(stateVariable) or __verifier_old_bool(stateVariable) to reference values from the start of the function execution. - A quantified postcondition MUST start with forall. For instance, a quantified postcondition look like /// @notice postcondition forall (uint x) condition. Without the forall at the beginning, the postcondition is invalid. - YOU MUST SPECIFY THE RANGE when postconditions quantify over arrays. For example, for array arr a postcondition quantification would look like /// @notice postcondition forall (uint i) !(0 <= i && i < arr.length) || condition. Without the range, the postcondition is likely to be invalid. - The implication operator "==>" is not valid in solc-verify notation, so it must appear NOWHERE in a postcondition. For instance, a postcondition of the form /// @notice postcondition condition1 ==> condition2 is invalid. Similarly, a postcondition of the form /// @notice postcondition (forall uint x) condition1 ==> condition2 is also invalid. You can use instead the notation !(condition) || condition2 to simulate the implication operator. For instance, /// @notice postcondition (forall uint x) condition1 ==> condition2 can be written as /// @notice postcondition !(condition1) || condition2.

    Your task is to annotate the function in the contract below:


        ```solidity
        pragma solidity >= 0.5.0;

        contract ERC123 {
            address public owner;
    address public trustedVerifier;
    address owner;
    address dataHash;
    bool verified;
    mapping(bytes32 => Identity) private identities;
    mapping(address => mapping(bytes32 => bool)) private consents;

        **verifyIdentityByTrustedVerifier(bytes32 identityId, bool verified)**
- **Description**: Allows the designated trustedVerifier account to set or revoke the “verified” status of an on-chain identity. This function centralizes verification authority in a trusted off-chain party, enabling attestations (or de-attestations) of an identity’s authenticity without exposing or modifying the underlying data hash.
- **Parameters**:
    - `identityId`: The unique identifier for the identity to be verified.
    - `verified`: A boolean value indicating whether the identity is verified.
- **Events**:
    - IdentityVerified(address indexed owner, bytes32 indexed identityId, bool verified)
    - Emitted whenever a verification action occurs.
        - owner: The address of the identity’s owner (identities[identityId].owner).
        - identityId: The identifier of the identity.
        - verified: The new verification flag.

$ADD POSTCONDITION HERE
function verifyIdentityByTrustedVerifier(bytes32 identityId, bool verified) external;
        }
        ```

        EIP Documentation Snippet (if relevant to `verifyIdentityByTrustedVerifier`):
        <eip>
        No specific EIP segment found for this function.
        </eip>
        

=== ASSISTANT [2025-05-14 03:43:44] ===
```solidity
pragma solidity >= 0.5.0;

contract ERC123 {
    address public owner;
    address public trustedVerifier;
    address dataHash;
    bool verified;
    mapping(bytes32 => Identity) private identities;
    mapping(address => mapping(bytes32 => bool)) private consents;

    /// @notice postcondition identities[identityId].owner == owner
    /// @notice postcondition identities[identityId].verified == verified
    /// @notice postcondition __verifier_old_bool(identities[identityId].verified) != verified
    function verifyIdentityByTrustedVerifier(bytes32 identityId, bool verified) external;
}
``` 

### Explanation of Postconditions:
1. **`identities[identityId].owner == owner`**: This ensures that the owner of the identity being verified is the same as the current contract's owner, which is a necessary condition for the verification action.
  
2. **`identities[identityId].verified == verified`**: This postcondition checks that the verified status of the identity matches the value passed to the function, ensuring that the function correctly updates the verification status.

3. **`__verifier_old_bool(identities[identityId].verified) != verified`**: This condition ensures that the verification status has changed from its previous state, indicating that the function has performed an action (either setting or revoking verification).

=== END OF THREAD ===
