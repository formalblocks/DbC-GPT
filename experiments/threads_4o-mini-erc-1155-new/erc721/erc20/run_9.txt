Thread ID: thread_Og3HCzc7CJqcAvy2EpzMz1so
Request Type: erc721
Context: erc20
Run: 9

=== USER [2025-04-16 14:16:39] ===

    
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

    
    ```solidity
    pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

    ```
    
Here are examples of similar ERC formal specifications:
Example ERC ERC20 specification:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.5.7;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /// @notice  postcondition ( ( _balances[msg.sender] ==  __verifier_old_uint (_balances[msg.sender] ) - _value  && msg.sender  != _to ) ||   ( _balances[msg.sender] ==  __verifier_old_uint ( _balances[msg.sender]) && msg.sender  == _to ) &&  success )   || !success
    /// @notice  postcondition ( ( _balances[_to] ==  __verifier_old_uint ( _balances[_to] ) + _value  && msg.sender  != _to ) ||   ( _balances[_to] ==  __verifier_old_uint ( _balances[_to] ) && msg.sender  == _to )  )   || !success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /// @notice  postcondition ( ( _balances[_from] ==  __verifier_old_uint (_balances[_from] ) - _value  &&  _from  != _to ) || ( _balances[_from] ==  __verifier_old_uint ( _balances[_from] ) &&  _from == _to ) && success ) || !success 
    /// @notice  postcondition ( ( _balances[_to] ==  __verifier_old_uint ( _balances[_to] ) + _value  &&  _from  != _to ) || ( _balances[_to] ==  __verifier_old_uint ( _balances[_to] ) &&  _from  == _to ) && success ) || !success 
    /// @notice  postcondition ( _allowed[_from ][msg.sender] ==  __verifier_old_uint (_allowed[_from ][msg.sender] ) - _value && success) || ( _allowed[_from ][msg.sender] ==  __verifier_old_uint (_allowed[_from ][msg.sender]) && !success) ||  _from  == msg.sender
    /// @notice  postcondition  _allowed[_from ][msg.sender]  <= __verifier_old_uint (_allowed[_from ][msg.sender] ) ||  _from  == msg.sender
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /// @notice  postcondition (_allowed[msg.sender ][ _spender] ==  _value  &&  success) || ( _allowed[msg.sender ][ _spender] ==  __verifier_old_uint ( _allowed[msg.sender ][ _spender] ) && !success )    
    function approve(address _spender, uint256 _value) public returns (bool success);

    /// @notice postcondition _balances[_owner] == balance
    function balanceOf(address _owner) public view returns (uint256 balance);

    /// @notice postcondition _allowed[_owner][_spender] == remaining
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}

```

EIP ERC721 markdown below:

<eip>
pragma solidity ^0.4.20;

/// @title ERC-721 Non-Fungible Token Standard
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.
interface ERC721 /* is ERC165 */ {
    /// @dev This emits when ownership of any NFT changes by any mechanism.
    ///  This event emits when NFTs are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of NFTs
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that NFT (if any) is reset to none.
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    /// @dev This emits when the approved address for an NFT is changed or
    ///  reaffirmed. The zero address indicates there is no approved address.
    ///  When a Transfer event emits, this also indicates that the approved
    ///  address for that NFT (if any) is reset to none.
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);

    /// @dev This emits when an operator is enabled or disabled for an owner.
    ///  The operator can manage all NFTs of the owner.
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    /// @notice Count all NFTs assigned to an owner
    /// @dev NFTs assigned to the zero address are considered invalid, and this
    ///  function throws for queries about the zero address.
    /// @param _owner An address for whom to query the balance
    /// @return The number of NFTs owned by `_owner`, possibly zero
    function balanceOf(address _owner) external view returns (uint256);

    /// @notice Find the owner of an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @param _tokenId The identifier for an NFT
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    /// @param data Additional data with no specified format, sent in call to `_to`
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev This works identically to the other function with an extra data parameter,
    ///  except this function just sets data to "".
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
    ///  THEY MAY BE PERMANENTLY LOST
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Change or reaffirm the approved address for an NFT
    /// @dev The zero address indicates there is no approved address.
    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized
    ///  operator of the current owner.
    /// @param _approved The new approved NFT controller
    /// @param _tokenId The NFT to approve
    function approve(address _approved, uint256 _tokenId) external payable;

    /// @notice Enable or disable approval for a third party ("operator") to manage
    ///  all of `msg.sender`'s assets
    /// @dev Emits the ApprovalForAll event. The contract MUST allow
    ///  multiple operators per owner.
    /// @param _operator Address to add to the set of authorized operators
    /// @param _approved True if the operator is approved, false to revoke approval
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice Get the approved address for a single NFT
    /// @dev Throws if `_tokenId` is not a valid NFT.
    /// @param _tokenId The NFT to find the approved address for
    /// @return The approved address for this NFT, or the zero address if there is none
    function getApproved(uint256 _tokenId) external view returns (address);

    /// @notice Query if an address is an authorized operator for another address
    /// @param _owner The address that owns the NFTs
    /// @param _operator The address that acts on behalf of the owner
    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}

interface ERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

</eip>


=== ASSISTANT [2025-04-16 14:16:42] ===
Here are the postconditions for each function in the `IERC721` contract annotated using the solc-verify syntax, consistent with the ERC-721 standard:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _ownedTokensCount[_owner] == balance
        * @notice postcondition _owner != address(0)
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
        * @notice postcondition _approved != _tokenOwner[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender] == true
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
        * @notice postcondition _tokenApprovals[_tokenId] == approved
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition _operatorApprovals[_owner][_operator] == __verifier_old_uint(_operatorApprovals[_owner][_operator])
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

```

These annotations provide a formal specification for each function, capturing the expected state changes and conditions according to the ERC-721 standard. Specifically:

- `balanceOf` checks that the returned balance corresponds to the `_ownedTokensCount` for the given owner.
- `ownerOf` ensures the owner returned is exactly the stored owner of `_tokenId`.
- `approve` ensures the `_approved` address is set correctly in `_tokenApprovals` and certain conditions are met by `msg.sender`.
- `getApproved` returns the approved address for `_tokenId`, ensuring it's correctly retrieved.
- `setApprovalForAll` sets `_operatorApprovals` for the operator, as expected.
- `isApprovedForAll` checks for existing operator approvals, making sure they are unchanged.
- For `transferFrom` and both `safeTransferFrom` functions, the annotations ensure that ownership is transferred, counts are adjusted accordingly, and the token approval is reset.

=== USER [2025-04-16 14:17:04] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:62: solc-verify error: Invalid type for argument in function call. Invalid implicit conversion from bool to uint256 requested.
_operatorApprovals[_owner][_operator] == __verifier_old_uint(_operatorApprovals[_owner][_operator])
                                                             ^-----------------------------------^
Annotation:1:1: solc-verify error: Operator == not compatible with types bool and uint256
_operatorApprovals[_owner][_operator] == __verifier_old_uint(_operatorApprovals[_owner][_operator])
^-------------------------------------------------------------------------------------------------^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:90:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:17:08] ===
Below, I have provided the formal specifications for each function in the `IERC721` contract using the solc-verify syntax. The annotations reflect the expected behavior as prescribed by the ERC-721 standard.

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition _ownedTokensCount[_owner] == balance
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
        * @notice postcondition _approved != _tokenOwner[_tokenId] || _approved == address(0)
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
        * @notice postcondition _tokenApprovals[_tokenId] == approved
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition (result == _operatorApprovals[_owner][_operator])
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool result);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
        * @notice postcondition _to != address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
        * @notice postcondition _to != address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
        * @notice postcondition _to != address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Explanation:

- **`balanceOf`**:
  - Checks that the `_ownedTokensCount` for `_owner` matches the returned `balance`.
  - Ensures `_owner` is not the zero address.

- **`ownerOf`**:
  - Ensures that the function returns the actual owner stored in `_tokenOwner` for `_tokenId`.
  - Ensures the returned owner is not the zero address.

- **`approve`**:
  - Changes the `_tokenApprovals[_tokenId]` to `_approved`.
  - Validates that `_approved` is not the current owner unless it's the zero address.
  - Ensures that the `msg.sender` is either the owner of `_tokenId` or an approved operator.

- **`getApproved`**:
  - Ensures it returns the correctly stored approved address for `_tokenId`.

- **`setApprovalForAll`**:
  - Sets `_operatorApprovals` for the operator specified.

- **`isApprovedForAll`**:
  - Returns whether the given `_operator` is an approved operator for `_owner`.

- **`transferFrom`**, **`safeTransferFrom`**:
  - Ensure ownership is transferred by updating `_tokenOwner`.
  - Adjust the `_ownedTokensCount` for `_from` and `_to`.
  - Reset `_tokenApprovals[_tokenId]` to zero.
  - Ensure destination address `_to` is not zero.

These annotations capture the logic of ownership transfer and approval management, consistent with the ERC-721 specification.

=== USER [2025-04-16 14:17:26] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:2: solc-verify error: Undeclared identifier.
(result == _operatorApprovals[_owner][_operator])
 ^----^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:90:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:17:28] ===
To correctly add formal verification postconditions that conform to the ERC-721 standard, we need to specify the annotations such that they match the function behaviors as per the standard. Here’s the corrected and annotated contract using solc-verify syntax.

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition _owner == _tokenOwner[_tokenId]
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition isApprovedForAll == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool isApprovedForAll);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _from == _to
        * @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _from == _to
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Key Points:

- **`balanceOf`**: Checks that the function returns the number of NFTs owned by `_owner`, and `_owner` should not be the zero address.
  
- **`ownerOf`**: Ensures the function returns the correct owner of the specified `_tokenId`, and the owner should not be the zero address.

- **`approve`**: Establishes that the `_tokenApprovals` mapping for the given `_tokenId` is set to `_approved` and `msg.sender` can only approve if they are the owner or an authorized operator for the owner.

- **`getApproved`**: Confirms the function returns the current approved address for the `_tokenId`.

- **`setApprovalForAll`**: Sets the `_operatorApprovals` mapping correctly based on the `_approved` status.

- **`isApprovedForAll`**: Verifies that the function returns whether `_operator` is an approved operator for `_owner`.

- **`transferFrom`** and **`safeTransferFrom`** functions ensure that:
  - Ownership of the NFT is transferred to `_to`.
  - Token owner counts are updated correctly for both `_from` and `_to` (special handling if `_from` and `_to` are the same).
  - The token approval is reset.

These annotations are designed to capture essential state changes and operator permissions required by the ERC-721 standard.

=== USER [2025-04-16 14:17:52] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:1: solc-verify error: Operator == not compatible with types function (address,address) view returns (bool) and bool
isApprovedForAll == _operatorApprovals[_owner][_operator]
^-------------------------------------------------------^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:88:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:17:54] ===
To ensure formal verification conditions are correctly expressed for the `IERC721` contract, we need to define postconditions that reflect the constraints and state changes expected by the ERC-721 standard. Listed below are the annotations for each function:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition _owner == _tokenOwner[_tokenId]
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition result == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool result);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]))
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]))
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]))
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]))
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition _ownedTokensCount[_from] == (__verifier_old_uint(_ownedTokensCount[_from]) - 1) || (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]))
        * @notice postcondition _ownedTokensCount[_to] == (__verifier_old_uint(_ownedTokensCount[_to]) + 1) || (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]))
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Explanation:

- **`balanceOf`**:
  - Ensures the balance returned matches the `_ownedTokensCount` for `_owner`.
  - Requires `_owner` to not be the zero address.

- **`ownerOf`**:
  - Verifies the `_owner` of `_tokenId` and ensures it is not the zero address.

- **`approve`**:
  - Requires that `msg.sender` is either the owner or an authorized operator.
  - Updates the `_tokenApprovals[_tokenId]` to `_approved`.

- **`getApproved`**:
  - Retrieves the approved address for `_tokenId`, and ensures that `_tokenId` has an owner.

- **`setApprovalForAll`**:
  - Updates the approval status of the specified operator correctly.

- **`isApprovedForAll`**:
  - Verifies that it returns whether `_operator` is approved for all assets of `_owner`.

- **`transferFrom`** and **`safeTransferFrom`**:
  - Ensure ownership transfer by updating `_tokenOwner`.
  - Adjust `_ownedTokensCount` considering self-transfer scenarios.
  - Reset the token approval.

These annotations maintain consistency and reflect ERC-721’s behavior, ensuring that the contract operates according to its specification.

=== USER [2025-04-16 14:18:16] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:1: solc-verify error: Undeclared identifier.
result == _operatorApprovals[_owner][_operator]
^----^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:89:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:18:18] ===
To ensure the contract's behavior aligns with the expected standards of ERC-721, we'll annotate each function in the `IERC721` contract interface with appropriate postconditions using solc-verify syntax:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition result == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool result);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Explanation of Postconditions:

- **`balanceOf`**:
  - Ensures that `_owner` is a valid address (not zero).
  - Asserts the balance returned is equal to `_ownedTokensCount[_owner]`.

- **`ownerOf`**:
  - Confirms `_owner` is equal to the stored owner of the `_tokenId` and not zero.

- **`approve`**:
  - Ensures the caller is authorized to approve, either as the owner or via operator approval.
  - Sets `_tokenApprovals[_tokenId]` to `_approved`.

- **`getApproved`**:
  - Returns the correctly stored approved address for a given `_tokenId`.

- **`setApprovalForAll`**:
  - Updates `_operatorApprovals[msg.sender][_operator]` status to `_approved`.

- **`isApprovedForAll`**:
  - Returns whether `_operator` is approved for all assets of `_owner`.

- **`transferFrom`** and **`safeTransferFrom`**:
  - Verify ownership has changed to `_to`.
  - Update `_ownedTokensCount` for `_from` and `_to` with handling for self-transfers.
  - Resets `_tokenApprovals[_tokenId]` to zero following a transfer.

These postconditions reflect the contractual obligations and expected state changes in compliance with the ERC-721 standard, ensuring proper management of asset ownership and approvals.

=== USER [2025-04-16 14:18:42] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:1: solc-verify error: Undeclared identifier.
result == _operatorApprovals[_owner][_operator]
^----^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:89:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:18:45] ===
To properly add formal verification conditions (postconditions) that align with the ERC-721 standard, each function in the `IERC721` contract requires specific annotations. These annotations capture the intended behavior and state changes of each function. Below is the contract annotated using the `solc-verify` syntax:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition approvedForAll == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool approvedForAll);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Key Postconditions Explanation:

- **`balanceOf`**:
  - The owner must be a valid address.
  - The balance returned must reflect the count of tokens owned by `_owner`.

- **`ownerOf`**:
  - The function must return the actual owner from `_tokenOwner[_tokenId]`.
  - The retrieved owner must not be the zero address.

- **`approve`**:
  - Checks that the caller is the owner or an authorized operator.
  - Updates the `_tokenApprovals[_tokenId]` to `_approved`.

- **`getApproved`**:
  - Confirms that the returned value matches the token approval mapping.

- **`setApprovalForAll`**:
  - Adjusts the approval status of the specified operator correctly.

- **`isApprovedForAll`**:
  - Verifies whether `_operator` is approved to operate all of `_owner`'s assets.

- **`transferFrom`** and **`safeTransferFrom`**:
  - Ensure the token ownership change to `_to` is reflected.
  - Adjust the `_ownedTokensCount` for `_from` and `_to` and handle self-transfer cases.
  - Reset the approval for the transferred token.

These postconditions reflect the correct behavior and expected state transitions according to the ERC-721 standard.

=== USER [2025-04-16 14:19:07] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:1: solc-verify error: Undeclared identifier.
approvedForAll == _operatorApprovals[_owner][_operator]
^------------^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:89:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:19:11] ===
To ensure the formal specification of the ERC-721 contract interface meets standard requirements, and to avoid errors in translation or compilation, you should use the exact phrasing and variable usage as required by the ERC documentation. Below are the annotations with corrected syntax and valid identifiers.

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition isApprovedForAll == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool isApprovedForAll);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Key Points:

- **Matching Output Variables**: Ensures the annotations provide clear outcomes for the function. I corrected the `isApprovedForAll` annotation to match the expected result variable properly defined as `isApprovedForAll` in the function signature.
  
- **Consistency in Condition Statements**: Consistent use of conditions within all transfer functions, ensuring logical operations reflect the self-transfer scenario and post-transfer state accurately.

- **Utilizing Existing State Variables**: The annotations only refer to existing state variables and parameters to prevent undeclared identifier issues.

This corrected version should align better with requirements and avoid compile-time annotation translation errors.

=== USER [2025-04-16 14:19:48] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:1: solc-verify error: Operator == not compatible with types function (address,address) view returns (bool) and bool
isApprovedForAll == _operatorApprovals[_owner][_operator]
^-------------------------------------------------------^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:89:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:20:08] ===
Here is the annotated `IERC721` contract with proper formal verification conditions using the `solc-verify` syntax:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition (_tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]) || _tokenOwner[_tokenId] == address(0)
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition isApprovedForAll == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool isApprovedForAll);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Key Postconditions:

- **`balanceOf`**:
  - `_owner` cannot be zero.
  - Ensures `balance` corresponds to the owned token count.

- **`ownerOf`**:
  - Ensures `_owner` matches the `_tokenOwner[_tokenId]`.
  - `_owner` cannot be zero.

- **`approve`**:
  - Allows `_approved` to be set only if the sender is the owner or an authorized operator.
  - Updates `_tokenApprovals`.

- **`getApproved`**:
  - Returns the current approved address for `_tokenId`, ensuring it's properly stored.

- **`setApprovalForAll`**:
  - Sets `_approved` status for the given `_operator`.

- **`isApprovedForAll`**:
  - Checks and returns approval status of `_operator`.

- **`transferFrom`** and **`safeTransferFrom`**:
  - Handles transfers updating the token and the balances, considering self-transfers.
  - Ensures `_tokenApprovals` are reset after the transfer.

These conditions ensure the expected behavior per the ERC-721 standard, maintaining logical consistency and proper operation of state changes within the contract.

=== USER [2025-04-16 14:20:34] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:1: solc-verify error: Operator == not compatible with types function (address,address) view returns (bool) and bool
isApprovedForAll == _operatorApprovals[_owner][_operator]
^-------------------------------------------------------^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:89:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:20:41] ===
To add the necessary annotations using the solc-verify syntax for formal verification, we need to make sure that each function's postconditions match the expected behavior according to the ERC-721 standard. Below are annotations for each function:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition (_tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender]) || _tokenOwner[_tokenId] == address(0)
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition _operatorApprovals[_owner][_operator] == result
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool result);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Key Postconditions Explanation:

- **`balanceOf`**: Validates that `_owner` is not a zero address and ensures `balance` equals `_ownedTokensCount[_owner]`.

- **`ownerOf`**: Confirms `_owner` as the owner of `_tokenId` and ensures the owner is not zero.

- **`approve`**: Ensures that `_approved` is set for `_tokenId` only if `msg.sender` is the owner or authorized operator, or when the token has no owner.

- **`getApproved`**: Assures the return matches the `_tokenApprovals[_tokenId]` mapping, and the token has a valid owner.

- **`setApprovalForAll`**: Ensures that `_operator` is set to `_approved` status for all tokens owned by `msg.sender`.

- **`isApprovedForAll`**: Returns the status of `_operatorApprovals` for `_owner` and `_operator`.

- **`transferFrom`**, **`safeTransferFrom`**: Properly handle the transfer logic ensuring:
  - Ownership is transferred to `_to`.
  - Balances are updated correctly, reduced from `_from` and added to `_to`, considering self-transfers.
  - Approval is reset to `address(0)` post-transfer.

These annotations incorporate expected functional behaviors and maintain consistency with the ERC-721 standard.

=== USER [2025-04-16 14:21:02] ===

        
    Task:
        - You are given a smart contract interface and need to add formal verification conditions for each function.
        - Read the ERC documentation to understand the contract's behavior.
        - For each function, add postconditions by replacing "$ADD POSTCONDITION HERE" with one or more appropriate postconditions.
        - Use the solc-verify syntax: /// @notice postcondition [condition]
        
    Requirements:
        - Each function must have appropriate postconditions
        - Conditions must correctly represent the expected behavior per the ERC standard
        - Conditions for all functions must be consistent with each other
        - Annotate with postconditions above each function
        
    Verification Guidelines:
        - Use ONLY state variables exactly as declared in the contract (_balances, _allowed, _totalSupply)
        - Use ONLY parameter names exactly as they appear in function signatures (_to, _from, _value, etc.)
        - DO NOT create short variable names like 'bal', 't', 's', 'u', 'v', or 'rem'
        - For referencing previous state values, use __verifier_old_uint(stateVariable)
        - For functions that return success, handle both success and failure cases: (condition && success) || !success
        - For self-transfers, add special handling when sender == recipient
        - View functions should relate return values directly to state variables
        - Ensure consistency between related functions (e.g., transfer and transferFrom)
        
    Your task is to annotate this contract with proper solc-verify postconditions:

        
        ```solidity
            pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;

    mapping (uint256 => address) private _tokenApprovals;

    mapping (address => uint256) private _ownedTokensCount;

    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice Count all NFTs assigned to an owner
        * @dev NFTs assigned to the zero address are considered invalid, and this
        *  function throws for queries about the zero address.
        * @param _owner An address for whom to query the balance
        * @return The number of NFTs owned by `_owner`, possibly zero
        */
    $ADD POSTCONDITION HERE
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice Find the owner of an NFT
        * @dev NFTs assigned to zero address are considered invalid, and queries
        *  about them do throw.
        * @param _tokenId The identifier for an NFT
        * @return The address of the owner of the NFT
        */
    $ADD POSTCONDITION HERE
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice Change or reaffirm the approved address for an NFT
        * @dev The zero address indicates there is no approved address.
        *  Throws unless `msg.sender` is the current NFT owner, or an authorized
        *  operator of the current owner.
        * @param _approved The new approved NFT controller
        * @param _tokenId The NFT to approve
        */
    $ADD POSTCONDITION HERE
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice Get the approved address for a single NFT
        * @dev Throws if `_tokenId` is not a valid NFT.
        * @param _tokenId The NFT to find the approved address for
        * @return The approved address for this NFT, or the zero address if there is none
        */
    $ADD POSTCONDITION HERE
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice Enable or disable approval for a third party ("operator") to manage
        *  all of `msg.sender`'s assets
        * @dev Emits the ApprovalForAll event. The contract MUST allow
        *  multiple operators per owner.
        * @param _operator Address to add to the set of authorized operators
        * @param _approved True if the operator is approved, false to revoke approval
        */
    $ADD POSTCONDITION HERE
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice Query if an address is an authorized operator for another address
        * @param _owner The address that owns the NFTs
        * @param _operator The address that acts on behalf of the owner
        * @return True if `_operator` is an approved operator for `_owner`, false otherwise
        */
    $ADD POSTCONDITION HERE
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /**
        * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
        *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
        *  THEY MAY BE PERMANENTLY LOST
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev This works identically to the other function with an extra data parameter,
        *  except this function just sets data to "".
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice Transfers the ownership of an NFT from one address to another address
        * @dev Throws unless `msg.sender` is the current owner, an authorized
        *  operator, or the approved address for this NFT. Throws if `_from` is
        *  not the current owner. Throws if `_to` is the zero address. Throws if
        *  `_tokenId` is not a valid NFT. When transfer is complete, this function
        *  checks if `_to` is a smart contract (code size > 0). If so, it calls
        *  `onERC721Received` on `_to` and throws if the return value is not
        *  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
        * @param _from The current owner of the NFT
        * @param _to The new owner
        * @param _tokenId The NFT to transfer
        * @param data Additional data with no specified format, sent in call to `_to`
        */
    $ADD POSTCONDITION HERE
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}

        ```
        Error while running compiler, details:
Warning: This is a pre-release compiler version, please do not use it in production.
./solc_verify_generator/ERC721/imp/Address.sol:14:25: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
    function isContract(address account) internal view returns (bool) {
                        ^-------------^
./solc_verify_generator/ERC721/imp/Address.sol:15:9: Warning: Unused local variable.
        uint256 size;
        ^----------^
./solc_verify_generator/ERC721/imp/Address.sol:14:5: Warning: Function state mutability can be restricted to pure
    function isContract(address account) internal view returns (bool) {
    ^ (Relevant source part starts here and spans across multiple lines).

======= Converting to Boogie IVL =======

======= ./solc_verify_generator/ERC721/imp/Address.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/ERC721_merge.sol =======
Annotation:1:42: solc-verify error: Undeclared identifier.
_operatorApprovals[_owner][_operator] == result
                                         ^----^

======= ./solc_verify_generator/ERC721/imp/IERC165.sol =======

======= ./solc_verify_generator/ERC721/imp/IERC721Receiver.sol =======

======= ./solc_verify_generator/ERC721/imp/SafeMath.sol =======
./solc_verify_generator/ERC721/imp/ERC721_merge.sol:89:5: solc-verify error: Error(s) while translating annotation for node
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved) {
    ^ (Relevant source part starts here and spans across multiple lines).



=== ASSISTANT [2025-04-16 14:21:10] ===
To add proper verification annotations to the `IERC721` contract, we need to ensure that the postconditions accurately describe the state changes and conditions expected by the ERC-721 standard. Let me update the contract with the correct postconditions, taking into account correct variable usage and expected functionality. Below is the annotated contract:

```solidity
pragma solidity >=0.5.0;

contract IERC721 {

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /**
        * @notice postcondition _owner != address(0)
        * @notice postcondition balance == _ownedTokensCount[_owner]
    */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
        * @notice postcondition _owner == _tokenOwner[_tokenId]
        * @notice postcondition _owner != address(0)
    */
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /**
        * @notice postcondition (_tokenOwner[_tokenId] == msg.sender || _operatorApprovals[_tokenOwner[_tokenId]][msg.sender])
        * @notice postcondition _tokenApprovals[_tokenId] == _approved
    */
    function approve(address _approved, uint256 _tokenId) external;

    /**
        * @notice postcondition approved == _tokenApprovals[_tokenId]
        * @notice postcondition _tokenOwner[_tokenId] != address(0)
    */
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /**
        * @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    */
    function setApprovalForAll(address _operator, bool _approved) external;

    /**
        * @notice postcondition isApprovedForAll == _operatorApprovals[_owner][_operator]
    */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool isApprovedForAll);

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /**
        * @notice postcondition _tokenOwner[_tokenId] == _to
        * @notice postcondition (_from == _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])) || (_from != _to && _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1)
        * @notice postcondition (_from == _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])) || (_from != _to && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
        * @notice postcondition _tokenApprovals[_tokenId] == address(0)
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;
}
```

### Explanation:

- **`balanceOf`**: Validates that `_owner` cannot be the zero address and the function returns the number of NFTs owned by the specified `_owner`.
  
- **`ownerOf`**: Confirms that `_owner` is the correct owner of `_tokenId` and is not zero.

- **`approve`**: Ensures that `_approved` is set as the approved address of `_tokenId` only if the caller is the owner or an approved operator, and updates `_tokenApprovals`.

- **`getApproved`**: Retrieves the approved address for `_tokenId` from `_tokenApprovals`, and ensures `_tokenId` must have a valid owner.

- **`setApprovalForAll`**: Sets the `_operator` approval status for all tokens owned by the `msg.sender`.

- **`isApprovedForAll`**: Confirms the `result` corresponds to the actual operator approval status.

- **`transferFrom`**, **`safeTransferFrom`**: These functions update state conditions for transferring tokens, ensuring that:
  - Ownership of `_tokenId` is transferred to `_to`.
  - `_ownedTokensCount` for `_from` and `_to` is updated.
  - Resets `_tokenApprovals[_tokenId]` to zero, handling self-transfers appropriately.

These postconditions are aligned with the ERC-721 behavior and ensure consistent, correct function operations.

=== END OF THREAD ===
