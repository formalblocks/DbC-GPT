run,time_taken,iterations,verified,annotated_contract,status
1,326.13037729263306,10,False,,[]
2,107.7777407169342,2,True,"pragma solidity >= 0.5.0;

contract ERC1155 {

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    // Mapping from token ID to account balances
    mapping (uint256 => mapping(address => uint256)) private _balances;

    // Mapping from account to operator approvals
    mapping (address => mapping(address => bool)) private _operatorApprovals;

    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
    string private _uri;

    /// @notice postcondition balance == _balances[_id][_owner]
    function balanceOf(address _owner, uint256 _id) public view returns (uint256 balance);

    /// @notice postcondition forall (uint i) !(0 <= i && i < _owners.length) || batchBalances[i] == _balances[_ids[i]][_owners[i]]
    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns (uint256[] memory batchBalances);

    /// @notice postcondition _operator == _operator || __verifier_old_bool(_operatorApprovals[msg.sender][_operator]) != _approved
    function setApprovalForAll(address _operator, bool _approved) public;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) public view returns (bool approved);

    /// @notice postcondition (_to != address(0) && _value <= __verifier_old_uint(_balances[_id][_from])) || (_from != _to && _value == 0) || __verifier_old_uint(_balances[_id][_from]) == _balances[_id][_from] + _value
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) public;

    /// @notice postcondition forall (uint i) !(0 <= i && i < _ids.length) || (_values[i] <= _balances[_ids[i]][_from] && _to != address(0) && (_from != _to || _values[i] == 0) || __verifier_old_uint(_balances[_ids[i]][_from]) == _balances[_ids[i]][_from] + _values[i])
    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;
}
","[""Interaction: 2\nContext::[implicit_constructor]: OK\nERC1155::[constructor]: OK\nERC1155::uri: OK\nERC1155::balanceOf: OK\nERC1155::balanceOfBatch: OK\nERC1155::setApprovalForAll: OK\nERC1155::isApprovedForAll: OK\nERC1155::safeTransferFrom: ERROR\n - ./solc_verify_generator/ERC1155/imp/ERC1155_merge.sol:128:5: Postcondition '_to != address(0) && (_from != _to || _value == 0) || __verifier_old_uint(_balances[_id][_from]) == _balances[_id][_from] + _value' might not hold at end of function.\nERC1155::safeBatchTransferFrom: OK\nERC165::supportsInterface: OK\nERC165::[implicit_constructor]: OK\nIERC1155::[implicit_constructor]: OK\nIERC1155MetadataURI::[implicit_constructor]: OK\nIERC1155Receiver::[implicit_constructor]: OK\nIERC165::[implicit_constructor]: OK\nUse --show-warnings to see 18 warnings.\nErrors were found by the verifier.\n\n""]"
3,227.8105170726776,10,False,,[]
4,355.86279797554016,10,False,,[]
5,246.24186444282532,10,False,,[]
6,271.567622423172,10,False,,[]
7,235.22405767440796,10,False,,[]
8,227.94097185134888,10,False,,[]
9,234.57852721214294,10,False,,[]
10,252.4587905406952,10,False,,[]
