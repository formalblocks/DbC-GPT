run,time_taken,iterations,verified,annotated_contract,status
1,185.12604975700378,10,False,,[]
2,191.95993781089783,10,False,,[]
3,25.01497220993042,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.

    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && ( (_to == msg.sender) 
    ///     ? (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender])) 
    ///     : (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value) 
    /// )) || !success
    /// @notice postcondition (success && ( (_to == msg.sender) 
    ///     ? (_balances[_to] == __verifier_old_uint(_balances[_to])) 
    ///     : (_balances[_to] == __verifier_old_uint(_balances[_to]) + _value) 
    /// )) || !success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && ( (_from == _to) 
    ///     ? (_balances[_from] == __verifier_old_uint(_balances[_from])) 
    ///     : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value) 
    /// )) || !success
    /// @notice postcondition (success && ( (_from == _to) 
    ///     ? (_balances[_to] == __verifier_old_uint(_balances[_to])) 
    ///     : (_balances[_to] == __verifier_old_uint(_balances[_to]) + _value) 
    /// )) || !success
    /// @notice postcondition (success && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) || !success
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (success && _allowed[msg.sender][_spender] == _value) || !success
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition balance == _balances[_owner]
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition remaining == _allowed[_owner][_spender]
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
4,186.4046504497528,10,False,,[]
5,149.14910912513733,6,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && _to != msg.sender) || !success || (_to == msg.sender)
    /// @notice postcondition (!success || (_to != msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value) || (_to == msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender])))
    /// @notice postcondition (!success || (_to != msg.sender && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value) || (_to == msg.sender && _balances[_to] == __verifier_old_uint(_balances[_to])))
    /// @notice postcondition (success || (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) && _balances[_to] == __verifier_old_uint(_balances[_to])))
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && _from != _to) || !success || (_from == _to)
    /// @notice postcondition (!success || (_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value) || (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from])))
    /// @notice postcondition (!success || (_from != _to && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value) || (_from == _to && _balances[_to] == __verifier_old_uint(_balances[_to])))
    /// @notice postcondition (!success || (_allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value))
    /// @notice postcondition (success || (_balances[_from] == __verifier_old_uint(_balances[_from]) && _balances[_to] == __verifier_old_uint(_balances[_to]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender])))
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (!success || _allowed[msg.sender][_spender] == _value)
    /// @notice postcondition (success || _allowed[msg.sender][_spender] == __verifier_old_uint(_allowed[msg.sender][_spender]))
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition balance == _balances[_owner]
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition remaining == _allowed[_owner][_spender]
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
","[""Interaction: 4\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '(!success || (_to != msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value))' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '(!success || (_to == msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender])))' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:109:5: Postcondition '(!success || (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from])))' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:109:5: Postcondition '(!success || (_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value))' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 6\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '(!success || (_to != msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value))' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '(!success || (_to == msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender])))' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:109:5: Postcondition '(!success || (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from])))' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:109:5: Postcondition '(!success || (_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value))' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
6,158.0944550037384,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.

    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && ( (_balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value && (_to != msg.sender)) || (_to == msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender])) )) || !success
    /// @notice postcondition (success && (_balances[_to] == __verifier_old_uint(_balances[_to]) + _value || _to == msg.sender)) || !success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && ( (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value && (_from != _to)) || (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from])) )) || !success
    /// @notice postcondition (success && (_balances[_to] == __verifier_old_uint(_balances[_to]) + _value || _from == _to)) || !success
    /// @notice postcondition (success && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) || !success
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (success && _allowed[msg.sender][_spender] == _value) || !success
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition balance == _balances[_owner]
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition remaining == _allowed[_owner][_spender]
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
7,248.62065029144287,10,False,,"[""Interaction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:101:5: Postcondition '(success && ((_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) || (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender])))) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 5\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:103:5: Postcondition '(success && (_from != _to) && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) ' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:103:5: Postcondition '(success && (_from == _to) && _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 6\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:101:5: Postcondition '(success && (_from != _to) && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) || (success && (_from == _to) && _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender])) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 8\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:103:5: Postcondition '(success && (_from != _to) && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) ' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:103:5: Postcondition '(success && (_from == _to) && _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 9\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:107:5: Postcondition '(success &&      ((_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) ||       (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))) ) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 10\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:104:5: Postcondition '(success &&      ((_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) ||       (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))) ) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
8,29.07628107070923,0,True,"pragma solidity >=0.5.0;

contract ERC20 {

    mapping (address => uint) _balances;
    mapping (address => mapping (address => uint)) _allowed;
    uint public _totalSupply;

    /**
    * Returns the total token supply.
    */
    /// @notice postcondition supply == _totalSupply
    function totalSupply() public view returns (uint256 supply);

    /**
    * Transfers `_value` amount of tokens to address `_to`, and MUST fire the `Transfer` event.
    * The function SHOULD `throw` if the message caller's account balance does not have enough tokens to spend.

    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && _value <= __verifier_old_uint(_balances[msg.sender]) && ((_to != msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender]) - _value) || (_to == msg.sender && _balances[msg.sender] == __verifier_old_uint(_balances[msg.sender])))) || !success
    /// @notice postcondition (success && ((_to != msg.sender && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value) || (_to == msg.sender && _balances[_to] == __verifier_old_uint(_balances[_to])))) || !success
    function transfer(address _to, uint256 _value) public returns (bool success);

    /**
    * Transfers `_value` amount of tokens from address `_from` to address `_to`, and MUST fire the `Transfer` event.
    * The `transferFrom` method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf.
    * This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies.
    * The function SHOULD `throw` unless the `_from` account has deliberately authorized the sender of the message via some mechanism.
    * *Note* Transfers of 0 values MUST be treated as normal transfers and fire the `Transfer` event.
    */
    /// @notice postcondition (success && _value <= __verifier_old_uint(_balances[_from]) && _value <= __verifier_old_uint(_allowed[_from][msg.sender]) && ((_from != _to && _balances[_from] == __verifier_old_uint(_balances[_from]) - _value) || (_from == _to && _balances[_from] == __verifier_old_uint(_balances[_from])))) || !success
    /// @notice postcondition (success && ((_from != _to && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value) || (_from == _to && _balances[_to] == __verifier_old_uint(_balances[_to])))) || !success
    /// @notice postcondition (success && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) || !success
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    /**
    * Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount. If this function is called again it overwrites the current allowance with `_value`.
    */
    /// @notice postcondition (success && _allowed[msg.sender][_spender] == _value) || !success
    function approve(address _spender, uint256 _value) public returns (bool success);

    /**
    * Returns the account balance of another account with address `_owner`.
    */
    /// @notice postcondition balance == _balances[_owner]
    function balanceOf(address _owner) public view returns (uint256 balance);

    /**
    * Returns the amount which `_spender` is still allowed to withdraw from `_owner`.
    */
    /// @notice postcondition remaining == _allowed[_owner][_spender]
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
}
",[]
9,218.09956431388855,10,False,,[]
10,271.7687339782715,10,False,,"[""Interaction: 1\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:101:5: Postcondition '(success && ( (_from == _to) ? ( _balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) ) : ( _balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value ) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 2\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:101:5: Postcondition '(success && ((_from == _to) ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender])) : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value && _balances[_to] == __verifier_old_uint(_balances[_to]) + _value && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value))) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 3\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:107:5: Postcondition '(success && (     (_from == _to)          ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&            _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&            _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 4\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:107:5: Postcondition '(success && (     (_from == _to)         ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&            _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&            _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 5\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: OK\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:110:5: Postcondition '(success && (     (_from == _to)         ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_value == 0             ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _balances[_to] == __verifier_old_uint(_balances[_to]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))             : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&                _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&                _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value)           ) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 6\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:73:5: Postcondition '(success == (_balances[msg.sender] >= _value))' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:109:5: Postcondition '(success == (_allowed[_from][msg.sender] >= _value && _balances[_from] >= _value))' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 7\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:71:5: Postcondition 'success == (_balances[msg.sender] >= _value)' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition 'success == (_allowed[_from][msg.sender] >= _value && _balances[_from] >= _value)' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition '(success && (     (_from == _to)         ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_value == 0             ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _balances[_to] == __verifier_old_uint(_balances[_to]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))             : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&                _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&                _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value)           ) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 8\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:71:5: Postcondition 'success == (_balances[msg.sender] >= _value)' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition 'success == (_allowed[_from][msg.sender] >= _value && _balances[_from] >= _value)' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition '(success && (     (_from == _to)         ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_value == 0             ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _balances[_to] == __verifier_old_uint(_balances[_to]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))             : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&                _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&                _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value)           ) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 9\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:71:5: Postcondition '(success && (_balances[msg.sender] >= _value)) || !success' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition '(success && (_allowed[_from][msg.sender] >= _value && _balances[_from] >= _value)) || !success' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition '(success && (     (_from == _to)         ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_value == 0             ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _balances[_to] == __verifier_old_uint(_balances[_to]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))             : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&                _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&                _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value)           ) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n"", ""Interaction: 10\nERC20::totalSupply: OK\nERC20::balanceOf: OK\nERC20::allowance: OK\nERC20::transfer: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:71:5: Postcondition '(success && (_balances[msg.sender] >= _value)) || !success' might not hold at end of function.\nERC20::approve: OK\nERC20::transferFrom: ERROR\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition '(success && (_allowed[_from][msg.sender] >= _value && _balances[_from] >= _value)) || !success' might not hold at end of function.\n - ./solc_verify_generator/ERC20/imp/ERC20_merge.sol:112:5: Postcondition '(success && (     (_from == _to)         ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))         : (_value == 0             ? (_balances[_from] == __verifier_old_uint(_balances[_from]) && _balances[_to] == __verifier_old_uint(_balances[_to]) && _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]))             : (_balances[_from] == __verifier_old_uint(_balances[_from]) - _value &&                _balances[_to] == __verifier_old_uint(_balances[_to]) + _value &&                _allowed[_from][msg.sender] == __verifier_old_uint(_allowed[_from][msg.sender]) - _value)           ) )) || !success' might not hold at end of function.\nERC20::increaseAllowance: OK\nERC20::decreaseAllowance: OK\nERC20::[implicit_constructor]: OK\nIERC20::[implicit_constructor]: OK\nErrors were found by the verifier.\n\n""]"
